@page "/image-editor-advanced"
@inject IJSRuntime JS
@implements IDisposable
@rendermode InteractiveServer

<h3>Zaawansowana edycja obrazu</h3>

<!-- Kontener dla canvasu – obraz będzie skalowany do rozmiaru kontenera -->
<div id="canvasContainer" style="width: 100%; max-width: 800px; border: 1px solid #ccc; margin-bottom:10px;">
    <canvas id="imageCanvas" style="width: 100%;"></canvas>
</div>

<!-- Sterowanie przycinaniem, zapisywaniem oraz zoomowaniem -->
<div style="margin-bottom: 10px;">
    <button @onclick="CropImage">Przytnij obraz</button>
    <button @onclick="ClearCanvas">Wyczyść zmiany</button>
    <button @onclick="SaveImage">Zapisz obraz</button>
</div>

<!-- Dodawanie własnego tekstu -->
<div style="margin-bottom: 10px;">
    <label for="textInput">Dodaj tekst: </label>
    <input id="textInput" type="text" @bind="UserText" placeholder="Wprowadź tekst" />
    <button @onclick="AddCustomText">Dodaj tekst</button>
</div>

<!-- Ustawienia rysowania oraz kolor kształtów -->
<div style="margin-bottom: 10px;">
    <label for="lineColor">Kolor linii/kształtów: </label>
    <input id="lineColor" type="color" @bind="LineColor" />
    <label for="lineWidth">Grubość linii: </label>
    <input id="lineWidth" type="number" min="1" max="20" @bind="LineWidth" style="width:60px;" />
    <button @onclick="SetDrawingOptions">Ustaw opcje rysowania</button>
</div>

<!-- Przyciski skalowania obrazu -->
<div style="margin-bottom: 10px;">
    <button @onclick="ZoomIn">+</button>
    <button @onclick="ZoomOut">-</button>
</div>

<!-- Tryb rysowania – pokazujemy właściwy przycisk w zależności od flagi -->
<div style="margin-bottom: 10px;">
    @if (IsDrawingModeEnabled)
    {
        <button @onclick="DisableDrawing">Wyłącz rysowanie</button>
    }
    else
    {
        <button @onclick="EnableDrawing">Włącz rysowanie</button>
    }
</div>

<!-- Dodawanie kształtów -->
<div style="margin-bottom: 10px;">
    <button @onclick="DrawRectangle">Dodaj prostokąt</button>
    <button @onclick="DrawCircle">Dodaj okrąg</button>
    <button @onclick="DrawLine">Dodaj linię</button>
    <button @onclick="DrawArrow">Dodaj strzałkę</button>
    @if (IsObjectSelected)
    {
        <button @onclick="RemoveSelectedObject">Usuń zaznaczony obiekt</button>
    }
</div>

@code {
    [Parameter]
    public string ImagePath { get; set; } = "Zrzut ekranu 2025-02-05 203728.png"; // Upewnij się, że obraz jest w wwwroot/images

    private string UserText { get; set; } = "Przykładowy tekst";
    private string LineColor { get; set; } = "#000000";
    private int LineWidth { get; set; } = 3;

    // Flagi statusu
    private bool IsObjectSelected { get; set; } = false;
    private bool IsDrawingModeEnabled { get; set; } = false;

    private DotNetObjectReference<ImageEditor_Advanced>? _dotNetRef;

    private async Task AddCustomText()
    {
        await JS.InvokeVoidAsync("fabricEditor.addCustomText", UserText);
    }

    private async Task SetDrawingOptions()
    {
        await JS.InvokeVoidAsync("fabricEditor.setDrawingOptions", LineColor, LineWidth);
    }

    private async Task EnableDrawing()
    {
        await JS.InvokeVoidAsync("fabricEditor.enableDrawingMode");
    }

    private async Task DisableDrawing()
    {
        await JS.InvokeVoidAsync("fabricEditor.disableDrawingMode");
    }

    private async Task DrawRectangle()
    {
        await JS.InvokeVoidAsync("fabricEditor.drawRectangle");
    }

    private async Task DrawCircle()
    {
        await JS.InvokeVoidAsync("fabricEditor.drawCircle");
    }

    private async Task DrawLine()
    {
        await JS.InvokeVoidAsync("fabricEditor.drawLine");
    }

    private async Task DrawArrow()
    {
        await JS.InvokeVoidAsync("fabricEditor.drawArrow");
    }

    private async Task CropImage()
    {
        var result = await JS.InvokeAsync<string>("fabricEditor.cropImage");
        if (result == "done")
        {
            Console.WriteLine("Obraz został przycięty i zaktualizowany.");
        }
    }

    private async Task ClearCanvas()
    {
        await JS.InvokeVoidAsync("fabricEditor.clearCanvas");
    }

    private async Task SaveImage()
    {
        var editedImage = await JS.InvokeAsync<string>("fabricEditor.getEditedImage");
        if (!string.IsNullOrEmpty(editedImage))
        {
            Console.WriteLine($"Zapisany obraz: {editedImage.Length} bajtów.");
            await SaveEditedImage(editedImage);
        }
    }

    private async Task SaveEditedImage(string base64Image)
    {
        var imageBytes = Convert.FromBase64String(base64Image.Split(',')[1]);
        var imagePath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", "edited.png");
        await System.IO.File.WriteAllBytesAsync(imagePath, imageBytes);
    }

    private async Task ZoomIn()
    {
        await JS.InvokeVoidAsync("fabricEditor.zoomIn");
    }

    private async Task ZoomOut()
    {
        await JS.InvokeVoidAsync("fabricEditor.zoomOut");
    }

    private async Task RemoveSelectedObject()
    {
        await JS.InvokeVoidAsync("fabricEditor.removeSelectedObject");
    }

    // Metoda wywoływana z JavaScript (JSInvokable) – aktualizuje flagi w C#
    [JSInvokable]
    public void UpdateStatus(bool isDrawingMode, bool isObjectSelected)
    {
        IsDrawingModeEnabled = isDrawingMode;
        IsObjectSelected = isObjectSelected;
        InvokeAsync(StateHasChanged);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Utwórz referencję do komponentu i przekaż ją do JS
            _dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("fabricEditor.initialize", "imageCanvas", ImagePath, _dotNetRef);
        }
    }

    public void Dispose()
    {
        _dotNetRef?.Dispose();
    }
}
